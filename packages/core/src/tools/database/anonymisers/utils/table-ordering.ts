/**
 * Utility functions for ordering database tables based on foreign key dependencies (generated by ðŸ¤–).
 */
import { EntityMetadata } from 'typeorm';

/**
 * Topologically sort entities based on foreign key dependencies
 *
 * This ensures that when inserting data:
 * - Parent tables (referenced by FKs) are inserted before child tables
 *
 * When deleting data:
 * - Child tables (with FKs) are deleted before parent tables
 *
 * @param entityMetas Array of TypeORM entity metadata
 * @param tableNames Array of table names to sort (only these will be included in output)
 * @returns Array of table names in dependency order (parents first)
 */
export function topologicalSortTables(
  entityMetas: EntityMetadata[],
  tableNames: string[]
): string[] {
  // Create a map of table name to entity metadata for quick lookup
  const tableToMeta = new Map(
    entityMetas.map((meta) => [meta.tableName, meta])
  );

  // Filter to only the tables we want to process
  const relevantMetas = entityMetas.filter((meta) =>
    tableNames.includes(meta.tableName)
  );

  // Build adjacency list: table -> tables it depends on (parent tables)
  const dependencies = new Map<string, Set<string>>();
  const allTables = new Set<string>();

  for (const meta of relevantMetas) {
    const tableName = meta.tableName;
    allTables.add(tableName);

    if (!dependencies.has(tableName)) {
      dependencies.set(tableName, new Set());
    }

    // Add dependencies from ManyToOne relations
    // These indicate foreign key relationships where this table references another
    for (const relation of meta.relations) {
      if (
        relation.relationType === 'many-to-one' &&
        relation.inverseEntityMetadata
      ) {
        const referencedTable = relation.inverseEntityMetadata.tableName;

        // Only add as dependency if it's in our list of tables to process
        if (
          tableNames.includes(referencedTable) &&
          referencedTable !== tableName
        ) {
          dependencies.get(tableName)!.add(referencedTable);
        }
      }
    }

    // Add dependencies from OneToOne relations that have a join column
    // (these are the "owning" side of the relationship)
    for (const relation of meta.relations) {
      if (
        relation.relationType === 'one-to-one' &&
        relation.joinColumns.length > 0 &&
        relation.inverseEntityMetadata
      ) {
        const referencedTable = relation.inverseEntityMetadata.tableName;

        // Only add as dependency if it's in our list of tables to process
        if (
          tableNames.includes(referencedTable) &&
          referencedTable !== tableName
        ) {
          dependencies.get(tableName)!.add(referencedTable);
        }
      }
    }
  }

  // Perform topological sort using Kahn's algorithm
  const result: string[] = [];
  const inDegree = new Map<string, number>();

  // Initialize in-degree count (number of dependencies each table has)
  for (const table of allTables) {
    inDegree.set(table, dependencies.get(table)?.size || 0);
  }

  // Queue of tables with no dependencies (in-degree 0)
  const queue: string[] = [];
  for (const [table, degree] of inDegree) {
    if (degree === 0) {
      queue.push(table);
    }
  }

  // Process queue
  while (queue.length > 0) {
    // Sort queue for consistent ordering
    queue.sort();
    const table = queue.shift()!;
    result.push(table);

    // Reduce in-degree for tables that depend on this one
    for (const [otherTable, deps] of dependencies) {
      if (deps.has(table)) {
        deps.delete(table);
        const newInDegree = deps.size;
        inDegree.set(otherTable, newInDegree);
        if (newInDegree === 0) {
          queue.push(otherTable);
        }
      }
    }
  }

  // Check for circular dependencies
  if (result.length !== allTables.size) {
    // If there's a cycle, fall back to original order but log warning
    const missing = [...allTables].filter((t) => !result.includes(t));
    console.warn(
      `Warning: Circular dependencies detected in tables: ${missing.join(', ')}`
    );
    console.warn('Falling back to original order for these tables');
    return [...result, ...missing];
  }

  return result;
}
