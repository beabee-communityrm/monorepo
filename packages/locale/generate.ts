/**
 * Script to load locale data from a Google sheet
 *
 * Run: `yarn generate` to generate a locale for the current branch.
 * Run: `yarn generate:branch [sheet name]` to generate a locale for a branch of your choice.
 *
 * Column headers should be locale codes, codes that start with an exclamation mark (!) are ignored.
 *
 * The script can optional load a second sheet to overwrite the main sheet, we add a new sheet for a
 * branch so changes for different features are kept separate.
 */
import fs from "fs";
import path from "path";
import { google } from "googleapis";
import MarkdownIt from "markdown-it";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const simpleMd = new MarkdownIt("zero").enable(["emphasis", "link"]);

simpleMd.renderer.rules.link_open = function (tokens, idx, options, env, self) {
  const token = tokens[idx];
  const hrefIndex = token.attrIndex("href");
  if (hrefIndex >= 0) {
    const href = token.attrs?.[hrefIndex]?.[1];
    if (href?.startsWith("http")) {
      token.attrPush(["target", "_blank"]);
      token.attrPush(["rel", "noopener noreferrer"]);
    }
  }
  return self.renderToken(tokens, idx, options);
};

const optHandlers = {
  md: (data) => simpleMd.render(data),
};

const auth = new google.auth.GoogleAuth({
  keyFile: path.join(__dirname, ".credentials.json"),
  scopes: ["https://www.googleapis.com/auth/spreadsheets.readonly"],
});

const sheets = google.sheets({ version: "v4", auth });

const localeData = {};
const localeConfig = {};

function processKeyData(keyOpts, keyData) {
  if (keyData) {
    return (
      keyOpts
        // Apply handlers
        .reduce((data, opt) => optHandlers[opt](data), keyData || "")
        // Santize special i18n character
        .replace(/@/g, "{'@'}")
    );
  }
}

async function loadSheet(name) {
  console.log("Loading sheet " + name);

  const resp = await sheets.spreadsheets.values.get({
    spreadsheetId: "1l35DW5OMi-xM8HXek5Q1jOxsXScINqqpEvPWDlpBPX8",
    range: name,
  });

  const headers = resp.data.values?.[0];

  if (!headers) {
    throw new Error("No headers found");
  }

  const rows = resp.data.values
    ?.slice(1)
    .map((row) =>
      Object.fromEntries(headers.map((header, i) => [header, row[i]])),
    )
    .filter((row) => row.key);

  if (!rows) {
    throw new Error("No rows found");
  }

  // Add locales to data
  const locales = headers.filter((h) => h !== "key" && !h.startsWith("!"));
  for (const locale of locales) {
    if (!localeData[locale]) {
      localeData[locale] = {};
      localeConfig[locale] = {};
    }
  }

  // Construct nested objects from a.b.c key paths
  for (const row of rows) {
    let isConfig = false;
    if (row.key.startsWith("_")) {
      row.key = row.key.slice(1);
      isConfig = true;
    }

    const keyParts = row.key.split(".");
    const [lastKeyPart, ...keyOpts] = keyParts.pop().split(":");

    for (const locale of locales) {
      let localeDataPart = isConfig ? localeConfig[locale] : localeData[locale];

      for (const part of keyParts) {
        if (!localeDataPart[part]) {
          localeDataPart[part] = {};
        }
        localeDataPart = localeDataPart[part];
      }

      if (localeDataPart[lastKeyPart] !== undefined) {
        console.log("Duplicate key " + row.key);
      }

      localeDataPart[lastKeyPart] = isConfig
        ? row[locale]
        : processKeyData(keyOpts, row[locale]);
    }
  }
}

// Recursively sort for predictable output
function sortObject(obj) {
  const ret = {};
  for (const key of Object.keys(obj).sort()) {
    ret[key] = typeof obj[key] === "object" ? sortObject(obj[key]) : obj[key];
  }
  return ret;
}

function saveFile(name: string, data: string) {
  console.log("Updating " + name);
  const filePath = path.join(__dirname, "./src/", name + ".ts");
  const dirPath = path.dirname(filePath);

  // Create directory if it doesn't exist
  fs.mkdirSync(dirPath, { recursive: true });

  fs.writeFileSync(
    filePath,
    "// This file is generated by generate.js\n" + data,
  );
}

/**
 * Converts a locale string to a valid camelCase variable name
 * @param name - The locale string (e.g. "de@easy", "en-US")
 * @returns The camelCase variable name (e.g. "deEasy", "enUs")
 */
function toCamelCase(name: string): string {
  // Get the last part of the path (e.g. "de@easy" from "locales/de@easy")
  const localeName = name.split("/").pop() || "";

  // Split by separators (@ or -) and capitalize each part except the first
  return localeName
    .split(/[@-]/)
    .map((part, index) =>
      index === 0
        ? part.toLowerCase()
        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase(),
    )
    .join("");
}

function saveJsonFile(name: string, data: any) {
  const exportName = toCamelCase(name);

  // Filter out undefined values recursively
  const filterUndefined = (obj: any): any => {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }

    const filtered: any = {};
    for (const [key, value] of Object.entries(obj)) {
      if (value !== undefined) {
        filtered[key] =
          typeof value === "object" ? filterUndefined(value) : value;
      }
    }
    return filtered;
  };

  // Convert object to string with unquoted keys
  const stringifyWithUnquotedKeys = (obj: any, indent = 0): string => {
    if (typeof obj !== "object" || obj === null) {
      return JSON.stringify(obj);
    }

    const spaces = " ".repeat((indent + 1) * 2);

    // Valid JavaScript identifier regex
    const validJSIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

    const entries = Object.entries(obj)
      .map(([key, value]) => {
        const valueStr =
          typeof value === "object" && value !== null
            ? stringifyWithUnquotedKeys(value, indent + 1)
            : JSON.stringify(value);

        // Quote the key if it's not a valid JS identifier
        const formattedKey = validJSIdentifier.test(key)
          ? key
          : JSON.stringify(key);

        return `${spaces}${formattedKey}: ${valueStr}`;
      })
      .join(",\n");

    return `{\n${entries}\n${" ".repeat(indent * 2)}}`;
  };

  const filteredData = filterUndefined(data);

  saveFile(
    name,
    "export const " +
      exportName +
      " = " +
      stringifyWithUnquotedKeys(filteredData) +
      " as const;\n",
  );
}

export async function generateLocales() {
  await loadSheet("Sheet1");

  if (process.argv[2] && process.argv[2] !== "main") {
    try {
      await loadSheet(process.argv[2]);
    } catch {}
  }

  let localesIndex = "";
  for (const locale in localeData) {
    saveJsonFile("./locales/" + locale, sortObject(localeData[locale]));
    localesIndex += `export * from './${locale}.js';\n`;
  }
  saveFile("./locales/index", localesIndex);
  saveJsonFile("./config", localeConfig);
}

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  generateLocales().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
